# store x as 1 through 10
x  =  1:10
x
# store y as x squared
y  =  x^2
# very simple plot of y against x
plot(y ~ x)
# more sophisticated plot with blue line and points
plot(y ~ x, type = "l", col = "blue", main = "y vs. x")
#check out the arguments
?plot
#what happens when I try to do something weird?
z  =  -3
sqrt(z)
z  =  complex(real = -3)
sqrt(z)
#sneak peek: data.frames
df = data.frame(x, y)
df
#say I wanted to start a "ggplot":
ggplot(df)
#First, let's install the package ggplot2
install.packages("ggplot2")
?ggplot
??ggplot2
install.packages("ggplot2")
#so, I just need to load that package to my current R session
# for this, I can use library() or require()
library(ggplot2)
#don't worry about the syntax of ggplot2 yet (future lesson).
#it's just an example to show you how to download new packages
ggplot(data = df, aes(x = x, y = y)) +
geom_line() +
geom_point() +
ggtitle("y vs. x")
#clear just x
rm(x)
#ls: looks at everything
ls()
#clear everything
rm(list = ls())
#now what will ls() return?
ls()
#clear the console
cat("\014")
x = c(1,2,3)
2 + 3
sqrt(4)
2 + 3
2 + 3
sqrt(4)
2 + 3
sqrt(4)
print("abc")
2 + 3
sqrt(4)
x
?sum
?mean
mean(x)
x = c(1, 2, 3)
x
x = c(1, 2, 4)
x
x = 1:10
x
x[10]
x[11] = 11
x
len(x)
length(x)
x = 1:5
x[11] = 11
x
mean(x)
sum(x)
x = 1:5:2
?seq
x = seq(1, 5, 2)
x
x = 1:10000
x
head(x)
head(x, 10)
head(x, 20)
tail(x)
getwd()
setwd("~/Desktop/repos/Intro-DS-F23/CodeDemos")
ls()
rm(list=ls())
data()
?AirPassengers
AirPassengers
AirPassengers  = 1
AirPassengers
data()
data()
data = CO2
data
data = c(1,2,3)
data
CO2
#First, let's install the package ggplot2
install.packages("ggplot2")
install.packages("ggplot2")
?ggplot
?ggplot
?ggplot2
??ggplot2
library(ggplot2)
?ggplot
#don't worry about the syntax of ggplot2 yet (future lesson).
#it's just an example to show you how to download new packages
ggplot(data = df, aes(x = x, y = y)) +
geom_line() +
geom_point() +
ggtitle("y vs. x")
#clear just x
rm(x)
#ls: looks at everything
ls()
my_dataframe_05 = data.frame(x = 1:3, y = 98:100, z = 1000:1002)
my_dataframe_05
#a
my_dataframe_06 = rbind(my_dataframe_05, qqq=-1)
my_dataframe_06
#b
my_dataframe_06 = rbind(my_dataframe_05, qqq=-1:-2)
#c
my_dataframe_06 = rbind(my_dataframe_05, qqq=-1:-99)
#d
my_dataframe_06 = rbind(my_dataframe_05, qqq=c(-1, -2))
my_dataframe_06
#b
my_dataframe_06 = rbind(my_dataframe_05, qqq=-1:-2)
my_dataframe_06
#c
my_dataframe_06 = rbind(my_dataframe_05, qqq=-1:-99)
my_dataframe_06
#e
my_dataframe_06 = rbind(my_dataframe_05, qqq=c("-1", -2))
my_dataframe_06
#f
my_dataframe_06 = rbind(my_dataframe_05, qqq = c("a", -2, -3)))
#f
my_dataframe_06 = rbind(my_dataframe_05, qqq = c("a", -2, -3))
my_dataframe_06
str(my_dataframe_06)
#f
my_dataframe_06 = rbind(my_dataframe_05, qqq = c("a", -2, -3))
str(my_dataframe_06)
my_dataframe_06
#f
my_dataframe_06 = rbind(my_dataframe_05, data.frame(qqq = c("a", -2, -3)))
#f
my_dataframe_06 = rbind(my_dataframe_05, qqq = c("a", -2, -3))
my_dataframe_06
row.names(my_dataframe_06) = c("1", "2", "3", "qqq")
my_dataframe_06
my_list = list(c(1, 2, 3), c(T, F), c(3.1415, 9), "abc")
my_list
##calling the first entry (which is a vector c(1, 2, 3))
my_list[[1]]
##calling the first entry (which is a vector c(1, 2, 3))
my_list[[1]][2]
##calling the first entry (which is a vector c(1, 2, 3))
my_list[[1]]
my_list[[4]]
#what happens if we use a single bracket?
my_list[1]
my_list[[1]]
str(my_list[[1]])
str(my_list[[1]]) #numeric
str(my_list[1])
matrix(1:9, nrow = 3)
my_list2 = list(matrix(1:9, nrow = 3), c(T, F, T), "ade")
#let's get the second row of the matrix in the first entry
my_list2[[1]]
#let's get the second row of the matrix in the first entry
my_list2[[1]][2,]
#equivalent to:
mat = my_list2[[1]]
mat[2,]
mat[1,]
mat[2,]
mat[3,]
mat[,1]
mat
mat[,1]
mat[,2]
mat[,3]
mat[3,3]
mat
mat[3,]
my_list
my_list2[1:2]
##naming and calling entries of a list using its name
my_list3 = list(Matrix = matrix(1:9, nrow = 3),
Logicals = c(T, T, F),
Numeric = c(3.145, 3/4))
my_list3
#calling the Logicals vector
my_list3[[2]]
$Logicals
#this is equivalent to...
my_list3$Logicals
unlist(my_list3)
##The unlist() function - this function will "unpack" a list by its
# components one at a time and concatenate them all to be a single vector.
# Note - this will cause coercion. Also, unlisting matrices takes entries
# according to columns
vec = unlist(my_list3)
str(vec)
typeof(vec)
matrix(1:9, ncol = 3)
diff_types = list("abc", matrix(1:4, nrow = 2), c(TRUE, FALSE))
unlist(diff_types)
typeof(unlist(diff_types))
#as an example of unlisting a matrix
unlist(matrix(1:9, ncol = 3)) #this didn't work! so, the input object must
# be a list!
unlist(list(matrix(1:9, ncol = 3)))
matrix(1:9, ncol = 9)
as.atomic(matrix(1:9, ncol = 9))
as.numeric(matrix(1:9, ncol = 9))
?unlist
##########
#Playing around with Data Frames in R
?ToothGrowth
ToothGrowth
#In general, we name the variables (i.e. the columns) and can easily call them
# using the $ argument. This is the same as in lists
ToothGrowth$dose
#get the second row
ToothGrowth[2, ] #this is still stored as a data frame since each column may have
ToothGrowth[2, 2]
ToothGrowth
ToothGrowth$supp
ToothGrowth$supp == "VC"
idx = ToothGrowth$supp == "VC"
ToothGrowth[idx,]
vc_guineapigs = ToothGrowth[idx,]
vc_guineapigs = ToothGrowth[ToothGrowth$supp == "VC",]
vc_guineapigs
#special solution:
vc_guineapigs = ToothGrowth[1:30,]
vc_guineapigs
index = ToothGrowth$len >= 10
long_teeth = ToothGrowth[index, ]
long_teeth
nrow(long_teeth)
index = (ToothGrowth$len >= 15)
long_teeth = ToothGrowth[index, ]
nrow(long_teeth)
index1 = (ToothGrowth$supp == "OJ")
subset1 = ToothGrowth[index1, ]
subset1
index2 = (ToothGrowth$dose == 2)
index2
subset2 = ToothGrowth[index2, ]
subset2
index1 = (ToothGrowth$supp == "OJ")
subset1 = ToothGrowth[index1, ]
subset1
index2 = (subset1$dose == 2)
index2
subset2 = subset1[index2, ]
subset2
ToothGrowth[(ToothGrowth$supp == "OJ")&(ToothGrowth$dose == 2),]
index1 = (ToothGrowth$supp == "OJ")
index1
index2 = (ToothGrowth$dose == 2)
index2
final = ToothGrowth[(index1)&(index2), ]
final
sum(final$len)
sum(final$len)/nrow(final)
nrow(final)
mean(final$len)
##Creating our own data frame
df1 = data.frame(Logicals = c(T, F, T, F), Age = c(21, 17, 32, 81))
str(df1)
#Example -
dffactors = data.frame(Logicals = c(T, F, T, F), Age = c(21, 17, 32, 81),
Strings = c("my", "name", "is", "bob"))
str(dffactors) #key point - this treats the Strings variable as a factor
dfstrings = data.frame(Logicals = c(T, F, T, F), Age = c(21, 17, 32, 81),
Strings = c("my", "name", "is", "bob"),
stringsAsFactors = FALSE)
str(dfstrings) #yay!
install.packages("tidyverse") #contains many contemporary
library(tidyverse)
data1 = iris
str(data1)
View(data1)
str(data1)
#coerce a data frame to be a tibble:
data2 = as_tibble(data1)
data2
str(data2) #we see that it is stored as a 'tbl_df', 'tbl',
#creating a tibble object
data3 = tibble(x = 1:5, y = 1,
z = x^2 + y
)
str(data2) #we see that it is stored as a 'tbl_df', 'tbl',
#creating a tibble object
data3 = tibble(x = 1:5, y = 1,
z = x^2 + y
)
data3
#creating a tibble object
data3 = tibble(x = 1:5, y = x^3,
z = x^2 + y
)
data3
#creating a tibble object
data3 = tibble(x = 1:5, y = z^2,
z = x^2 + y
)
#creating a tibble object
data3 = tibble(x = 1:5, y = x^3,
z = x^2 + y
)
data3
#creating a tibble object
data3 = tibble(x = 1:5, y = 1,
z = x^2 + y
)
data3
##tibbles are more flexible than data frames especially
#with naming of variables (columns). In fact, you can
#use any type of emoji or spaces in a name as long as
#you refer to them with back ticks ` `
tb = tibble(
`:)` = "smile",
` ` = "space",
`2000` = "number"
)
tb$`:)`
tb
tribble(
~x, ~y, ~z,
#--|--|----
"Dante", 0, 3.6,
"b", 1, 8.5
)
install.packages("nycflights13")
nycflights13::flights
#print 5 rows and show all columns
print(nycflights13::flights, n = 5, width = Inf)
#not very pretty but allows us to look at all the columns at once
View(nycflights13::flights)
df = tibble(
x = runif(5),
y = rnorm(5),
z = c("a", "b", "c", "d", "e")
)
df
set.seed(123)
df = tibble(
x = runif(5),
y = rnorm(5),
z = c("a", "b", "c", "d", "e")
)
df
#subsetting columns using the same method as data frames ($)
df$y
#flexible way using [[""]]
df[["x"]]
##calling columns by position
df[[1]] #give the first colu,mn of df
#can also use "old" way of calling columns as in data frame calls
df[, 1]
df[, c(1,3)]
##partial matching from a data frame
df_dataframe = data.frame(
dog = runif(5),
y = rnorm(5),
z = c("a", "b", "c", "d", "e")
)
df.dataframe$do
df_dataframe$do
df_dataframe$d
head(data1)
dev.new()
plot(x = data1$Sepal.Length, y = data1$Sepal.Width)
dev.new()
knitr::opts_chunk$set(echo = TRUE)
colorize <- function(x, color) {
if (knitr::is_latex_output()) {
sprintf("\\textcolor{%s}{%s}", color, x)
} else if (knitr::is_html_output()) {
sprintf("<span style='color: %s;'>%s</span>", color,
x)
} else x
}
# read in the movieratings.csv file
movieratings = read.csv("~/Desktop/repos/math372/data/movieratings.csv")
#look at the first 6 rows
head(movieratings)
movieratings = read.csv("~/Desktop/repos/math372/data/movieratings.csv")
head(movieratings)
mod = lm(movieratings$tomatometer_rating ~ movieratings$audience_rating,
data = movieratings)
summary(mod)
vcov(mod)
diag(vcov(mod))
sqrt(diag(vcov(mod)))
mod = lm(tomatometer_rating ~ audience_rating,
data = movieratings)
summary(mod)
?lm
y = movieratings$tomatometer_rating
mod = lm(y~x)
y = movieratings$tomatometer_rating
x = movieratings$audience_rating
mod = lm(y~x)
vcov(mod)
knitr::opts_chunk$set(echo = TRUE)
#Load the data
data(iris)
#Look at the data
iris
#Read a description of the data
help(iris)
#Display the column and row names of the data
colnames(iris)
rownames(iris)
#Look at the 10th row
iris[10,]
#Look at the 3rd column
iris[, 3]
#Alternatively, just look at the variable "Petal.Length"
iris$Petal.Length
#Store columns 1-2 and rows 10-20 for later use
subset_data <- iris[10:20, 1:2]
#Store the species names for later use
species_names <- iris$Species
#10th sample:
iris[10,]
#5 number summary of subset_data
sum_subset_data <- summary(subset_data)
sum_subset_data
#standard deviations of subset_data
sd_subset_data <- apply(subset_data, 2, sd)
sd_subset_data
atomic_vec <- c(1, 4, 3, 2, NA, 3.22, -44, 2, NA, 0, 22, 34)
pos_num <- sum(atomic_vec > 0, na.rm = TRUE)
pos_num
neg_num <- sum(atomic_vec <0, na.rm = TRUE)
neg_num
fib_vec <- rep(0, 1000)
fib_vec[1] <- 1
fib_vec[2] <- 1
for(i in 3:1000){
fib_vec[i] <- fib_vec[i - 1] + fib_vec[i - 2]
}
#first 8 entries
first_eight <- fib_vec[1:8]
first_eight
#last 8 entries
last_eight <- fib_vec[993:1000]
last_eight
z_n <- rep(0,999)
for(i in 0:999){
z_n[i] <- fib_vec[i + 1] / fib_vec[i]
}
#solution without for loops:
z_n = fib_vec[2:1000]/fib_vec[1:999]
z_n
#solution without for loops:
z_n1 = fib_vec[2:1000]/fib_vec[1:999]
z_n2 <- rep(0,999)
#alternative solution
for(i in 1:999){
z_n2[i] <- fib_vec[i + 1] / fib_vec[i]
}
z_n2
all(z_n1 == z_n2)
fib_matrix1 <- matrix(fib_vec, nrow = 100, ncol = 10, byrow = FALSE)
fib_matrix1
dim(fib_matrix1)
fibmatrix1[,:1]
fibmatrix1[,1]
fibmatrix_1[,1]
fib_matrix1 <- matrix(fib_vec, nrow = 100, ncol = 10, byrow = FALSE)
fibmatrix_1[,1]
fib_matrix1 <- matrix(fib_vec, nrow = 100, ncol = 10, byrow = FALSE)
fib_matrix1[,1]
fib_array <- array(fib_vec, dim=c(10, 10, 10))
mean(fib_matrix1[18,])
sd(fib_matrix2[, 8])
fib_matrix2 <- matrix(fib_vec, nrow = 100, ncol = 10, byrow = TRUE)
sd(fib_matrix2[, 8])
scaled_fib = fib_matrix2/1e7
sd(scaled_fib[, 8])
scaled_fib = fib_matrix2/1e10
sd(scaled_fib[, 8])
scaled_fib = fib_matrix2/1e20
sd(scaled_fib[, 8])
scaled_fib = fib_matrix2/1e30
sd(scaled_fib[, 8])
scaled_fib = fib_matrix2/1e100
sd(scaled_fib[, 8])
max(fib_matrix2)
scaled_fib = fib_matrix2/1e200
sd(scaled_fib[, 8])
1e2
scaled_fib = fib_matrix2 / 1e100
sd(scaled_fib[, 8])
scaled_fib = fib_matrix2 / 1e200
sd(scaled_fib[, 8])
